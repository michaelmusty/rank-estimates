intrinsic SE(E::CrvEll, prime_list::SeqEnum) -> FldReElt
  {Given a CrvEll E and a list of primes return the partial sum S_E(N) where N is the largest prime in the prime_list.}
  N := prime_list[#prime_list];
  RR := RealField(20);
  sum := RR!0;
  coeffs := Eltseq(E);
  for p in prime_list do
    assert IsPrime(p);
    FFp := FiniteField(p);
    coeffsFFp := [];
    for coeff in coeffs do
      Append(~coeffsFFp, FFp!coeff);
    end for;
    if IsEllipticCurve(coeffsFFp) then
      E := EllipticCurve(coeffsFFp);
      num_points := #E(FFp);
      sum +:= RR!(1-(p-1)/num_points)*RR!Log(p);
    end if;
  end for;
  return RR!sum;
end intrinsic;

intrinsic GE(SE::FldReElt, N::RngIntElt) -> FldReElt
  {Given the partial sum SE and a prime bound N, return the partial sum G_E(N).}
  RR := RealField(20);
  return RR!(1/(Log(N)-2))*SE;
end intrinsic;

intrinsic RankDatabaseComputeEstimate(s::RankDatabaseObject, N::RngIntElt) -> MonStgElt
  {Computes rank estimate S_E(N) for curve s in database up to desired prime bound N. Assumes working directory is repository rank-estimates. The idea here is to not discard previously computed partial sum.}
  directory := GetCurrentDirectory();
  name := s`RankDatabaseName;
  c := s`RankDatabaseConductor;
  n := s`RankDatabaseN; // current prime bound
  if s`RankDatabaseCoeffs eq [] then
    E := EllipticCurve(Sprintf("%o", name));
  else
    E := EllipticCurve(Sprintf("%o", s`RankDatabaseCoeffs));
  end if;
  assert Rank(E) eq s`RankDatabaseRank;
  if n lt N then // current prime bound less than desired prime bound
    if n le 1 then // we have not computed an estimate previously
      prime_list := PrimesUpTo(N);
    else // we have computed a previous estimate and should thus exclude some primes
      prime_list := PrimesInInterval(n+1, N);
    end if;
      s`RankDatabaseValue +:= SE(E, prime_list);
      s`RankDatabaseN := N;
      s`RankDatabaseEstimate := GE(s`RankDatabaseValue, prime_list[#prime_list]);
  end if;
  if s`RankDatabaseN gt 1 then
    s`RankDatabaseComputed := true;
  end if;
  ChangeDirectory(directory cat Sprintf("/RankDatabase/%o/", c));
  RankDatabaseWriteObject(s);
  ChangeDirectory(directory);
  returnText := Sprintf("%o written\n", name);
  return returnText;
end intrinsic;

intrinsic RankDatabaseComputeBetweenConductors(clow::RngIntElt, chigh::RngIntElt, N::RngIntElt) -> MonStgElt
  {Computes rank estimate S_E(N) for up to desired prime bound N for curves in database with conductors between clow and chigh. Assumes working directory is repository rank-estimates.}
  directory := GetCurrentDirectory();
  ChangeDirectory(directory cat "/RankDatabase/");
  ls := Pipe("ls", "");
  conductors := Split(ls, "\n");
  Cs := [];
  for i in {1..#conductors} do
    test := StringToInteger(conductors[i]);
    if test ge clow and test le chigh then
      Append(~Cs, test);
    end if;
  end for;
  for i in {1..#Cs} do
    ChangeDirectory(directory);
    f := RankDatabaseFilenames(Cs[i]);
    for j in {1..#f} do
      ChangeDirectory(directory cat Sprintf("/RankDatabase/%o/", Cs[i]));
      s := RankDatabaseAccessEntry(f[j]);
      ChangeDirectory(directory);
      RankDatabaseComputeEstimate(s, N);
    end for;
  end for;
  ChangeDirectory(directory);
  returnText := "\nEstimates computed:\n";
  returnText *:= Sprintf("  N = %o\n", N);
  returnText *:= Sprintf("  conductor lower bound = %o\n", clow);
  returnText *:= Sprintf("  conductor upper bound = %o\n", chigh);
  return returnText;
end intrinsic;
